<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="Generator" content="Kate, the KDE Advanced Text Editor" />
<title>SimulFullNetworkDiscovery.py</title>
</head>
<body>
<pre style='color:#1f1c1b;background-color:#ffffff;'>
<b><span style='color:#ff0000;'>#!/usr/bin/env python</span></b>
<b><span style='color:#ff0000;'># -*- coding: utf-8 -*-</span></b>
<b><span style='color:#ff0000;'># make a horizontal bar chart</span></b>
<b><span style='color:#ff0000;'>&quot;&quot;&quot;</span></b>
<b><span style='color:#ff0000;'>Dept. of Automatic Control</span></b>
<b><span style='color:#ff0000;'>    School of Electrical Engineering</span></b>
<b><span style='color:#ff0000;'>        KTH Kungliga Tekniska HÃ¶gskolan (Royal Institute of Technology)</span></b>
<b><span style='color:#ff0000;'>Created on Sat Dec 01 10:53:52 PM 2014</span></b>

<b><span style='color:#ff0000;'>@author: gonga</span></b>

<b><span style='color:#ff0000;'>New ideas of accerelating epidemic discovery.</span></b>
<b><span style='color:#ff0000;'>A frame consists of: (1) a discovery slot, where nodes use multichannel epidemic</span></b>
<b><span style='color:#ff0000;'>discovery, and (2) listening(announcement) where each node picks a slot to </span></b>
<b><span style='color:#ff0000;'>listen for a specific neighbor it has not yet heard </span></b>
<b><span style='color:#ff0000;'>&quot;&quot;&quot;</span></b>

<span style='color:#924c9d;'>import</span> matplotlib <span style='color:#924c9d;'>as</span> mpl
<span style='color:#924c9d;'>import</span> matplotlib.pyplot  <span style='color:#924c9d;'>as</span> plt
<span style='color:#924c9d;'>from</span> pylab <span style='color:#924c9d;'>import</span> <b>*</b>

<span style='color:#924c9d;'>import</span> math
<span style='color:#924c9d;'>import</span> numpy <span style='color:#924c9d;'>as</span> np
<span style='color:#924c9d;'>from</span> numpy <span style='color:#924c9d;'>import</span> mean
<span style='color:#924c9d;'>from</span> scipy <span style='color:#924c9d;'>import</span> stats
<span style='color:#924c9d;'>import</span> scipy <span style='color:#924c9d;'>as</span> sp


<span style='color:#924c9d;'>from</span> matplotlib <span style='color:#924c9d;'>import</span> rc
plt.rcParams[<b><span style='color:#bf0303;'>'ps.useafm'</span></b>] <b>=</b> <span style='color:#006e28;'>True</span>
<b><span style='color:#ff0000;'>#rc('font',**{'family':'sans-serif','sans-serif':['Helvetica']})</span></b>
<b><span style='color:#ff0000;'>#plt.rcParams['pdf.fonttype'] = 3 #[42 or 3]</span></b>
prop <b>=</b> matplotlib.font_manager.FontProperties(size<b>=</b><span style='color:#b08000;'>8</span>)


simSeed<b>=</b> <span style='color:#b08000;'>997</span>
rsObj <b>=</b> np.random.mtrand.RandomState(simSeed)

<b>class</b> Node:
    <b>def</b> <b><span style='color:#000e52;'>__init__</span></b>(<span style='color:#006e28;'>self</span>, <b><span style='color:#0000ff;'>id</span></b>, avgNodeDegree):
      <span style='color:#006e28;'>self</span>.<b><span style='color:#0000ff;'>id</span></b> <b>=</b> <b><span style='color:#0000ff;'>id</span></b>  
      <span style='color:#006e28;'>self</span>.neighLen <b>=</b> avgNodeDegree
      <span style='color:#006e28;'>self</span>.chId <b>=</b> <span style='color:#b08000;'>0</span>
    
      <span style='color:#006e28;'>self</span>.ownSlot <b>=</b> <span style='color:#006e28;'>None</span>
      <span style='color:#006e28;'>self</span>.ownChannel <b>=</b><span style='color:#006e28;'>None</span>
     
      <span style='color:#006e28;'>self</span>.state <b>=</b> <span style='color:#006e28;'>False</span>
      <span style='color:#006e28;'>self</span>.networkVec   <b>=</b> []
      <span style='color:#006e28;'>self</span>.notKnownNeigh<b>=</b>[]
      <span style='color:#006e28;'>self</span>.neighbors  <b>=</b> []
      <span style='color:#006e28;'>self</span>.neighbors1Hop <b>=</b> []
      
      <span style='color:#006e28;'>self</span>.xc0 <b>=</b> <span style='color:#b08000;'>0</span>
      <span style='color:#006e28;'>self</span>.yc0 <b>=</b> <span style='color:#b08000;'>0</span>
      <span style='color:#006e28;'>self</span>.hopCount    <b>=</b> <span style='color:#b08000;'>0</span>
      <span style='color:#006e28;'>self</span>.radioRadius <b>=</b> <span style='color:#b08000;'>20</span>

      <span style='color:#006e28;'>self</span>.networkVec.append(<span style='color:#006e28;'>self</span>)  
    
    <b>def</b> addCoordinates(<span style='color:#006e28;'>self</span>, x, y):
       <span style='color:#006e28;'>self</span>.xc0 <b>=</b> x
       <span style='color:#006e28;'>self</span>.yc0 <b>=</b> y
       
    <b>def</b> isNeighbor(<span style='color:#006e28;'>self</span>, nodeXY):
       
       <b>if</b> nodeXY.<b><span style='color:#0000ff;'>id</span></b> <b>!=</b> <span style='color:#006e28;'>self</span>.<b><span style='color:#0000ff;'>id</span></b>:
         d <b>=</b> math.sqrt( (nodeXY.xc0<b>-</b><span style='color:#006e28;'>self</span>.xc0)<b>**</b><span style='color:#b08000;'>2</span> <b>+</b> (nodeXY.yc0 <b>-</b><span style='color:#006e28;'>self</span>.yc0)<b>**</b><span style='color:#b08000;'>2</span> )
       
         <b>if</b> d <b>&lt;</b> <span style='color:#006e28;'>self</span>.radioRadius:
               <b>return</b> <span style='color:#006e28;'>True</span>
               
       <b>return</b> <span style='color:#006e28;'>False</span>
       
    <b>def</b> isNeighborByID(<span style='color:#006e28;'>self</span>, nID):
        <b>if</b> <span style='color:#006e28;'>self</span>.<b><span style='color:#0000ff;'>id</span></b> <b>!=</b> nID <b>and</b> nID <b>in</b> <span style='color:#006e28;'>self</span>.neighbors:
            <b>return</b> <span style='color:#006e28;'>True</span>
        <b>return</b> <span style='color:#006e28;'>False</span>
    
    <b>def</b> flushNeighbors(<span style='color:#006e28;'>self</span>):
       <span style='color:#006e28;'>self</span>.networkVec    <b>=</b> []    
       <span style='color:#006e28;'>self</span>.notKnownNeigh <b>=</b> []
       <span style='color:#006e28;'>self</span>.neighbors1Hop <b>=</b> []
       
       <span style='color:#006e28;'>self</span>.networkVec.append(<span style='color:#006e28;'>self</span>) 

    <b>def</b> addReceived(<span style='color:#006e28;'>self</span>, node):
        <b>if</b> node <b>not</b> <b>in</b> <span style='color:#006e28;'>self</span>.networkVec:
            <span style='color:#006e28;'>self</span>.networkVec.append(node)  
        <b>else</b>:
            idx <b>=</b> <span style='color:#006e28;'>self</span>.networkVec.index(node) 
            hop <b>=</b> <span style='color:#006e28;'>self</span>.networkVec[idx].hopCount
            
            <b>if</b> node.hopCount <b>&lt;</b> hop:
                <span style='color:#006e28;'>self</span>.networkVec[idx] <b>=</b> node

       
    <b>def</b> addNeighbor(<span style='color:#006e28;'>self</span>, neighId):
        <b>if</b> neighId <b>not</b> <b>in</b> <span style='color:#006e28;'>self</span>.neighbors1Hop:
            <span style='color:#006e28;'>self</span>.neighbors1Hop.append(neighId)
            
            <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>We have discovered the node.. remove it from not Known nodes</span></b><b><span style='color:#ff0000;'>'''</span></b>
            <b>if</b> neighId <b>in</b> <span style='color:#006e28;'>self</span>.notKnownNeigh:
                <span style='color:#006e28;'>self</span>.notKnownNeigh.remove(neighId)
            
    <b>def</b> addNotKnown(<span style='color:#006e28;'>self</span>, notID):
        <b>if</b> notID <b>not</b> <b>in</b> <span style='color:#006e28;'>self</span>.notKnownNeigh:
            <span style='color:#006e28;'>self</span>.notKnownNeigh.append(notID)
                  
    <b>def</b> allNetworkDiscovered(<span style='color:#006e28;'>self</span>):
        <b>return</b> <b><span style='color:#0000ff;'>len</span></b>(<span style='color:#006e28;'>self</span>.networkVec) <b>==</b> <span style='color:#006e28;'>self</span>.neighLen
                  
    <b>def</b> allNeighborsDiscovered(<span style='color:#006e28;'>self</span>):
	 <b>return</b> <b><span style='color:#0000ff;'>len</span></b>(<span style='color:#006e28;'>self</span>.neighbors) <b>==</b> <b><span style='color:#0000ff;'>len</span></b>(<span style='color:#006e28;'>self</span>.neighbors1Hop)
  
    <b>def</b> addChannel(<span style='color:#006e28;'>self</span>, chId):
        <span style='color:#006e28;'>self</span>.chId <b>=</b> chId
        
    <b>def</b> addOwn(<span style='color:#006e28;'>self</span>, channel, ownSlot):
        
        <span style='color:#006e28;'>self</span>.ownSlot <b>=</b> ownSlot
        <span style='color:#006e28;'>self</span>.ownChannel <b>=</b> channel
        
    <b>def</b> isOwnSlot(<span style='color:#006e28;'>self</span>, slotOffset):
        <b>if</b> <span style='color:#006e28;'>self</span>.ownSlot <b>==</b> slotOffset:
            <b>return</b> <span style='color:#006e28;'>True</span>
        <b>return</b> <span style='color:#006e28;'>False</span>        
        
    <b>def</b> transmitOwn(<span style='color:#006e28;'>self</span>, ptOwn):
        
        <span style='color:#006e28;'>self</span>.state <b>=</b> <span style='color:#006e28;'>False</span>        
        <span style='color:#006e28;'>self</span>.chId <b>=</b> <span style='color:#006e28;'>self</span>.ownChannel
                
        p <b>=</b> rsObj.uniform(<span style='color:#b08000;'>0</span>,<span style='color:#b08000;'>1</span>)
        
        <b>if</b> p <b>&lt;</b> ptOwn:
            <span style='color:#006e28;'>self</span>.state <b>=</b> <span style='color:#006e28;'>True</span>
               
    <b>def</b> disseminate(<span style='color:#006e28;'>self</span>, node):
        
        node.hopCount <b>=</b> node.hopCount <b>+</b> <span style='color:#b08000;'>1</span>
        
        <b>if</b> node.<b><span style='color:#0000ff;'>id</span></b> <b>!=</b> <span style='color:#006e28;'>self</span>.<b><span style='color:#0000ff;'>id</span></b>:
            <span style='color:#006e28;'>self</span>.addNeighbor(node.<b><span style='color:#0000ff;'>id</span></b>)
        
        <b>for</b> nodej <b>in</b> node.networkVec:            
            
            <b>if</b> nodej.<b><span style='color:#0000ff;'>id</span></b> <b>!=</b> <span style='color:#006e28;'>self</span>.<b><span style='color:#0000ff;'>id</span></b>:
                nodej.hopCount <b>=</b> nodej.hopCount <b>+</b> <span style='color:#b08000;'>1</span>
                hop <b>=</b> nodej.hopCount                
                
                <b>if</b> hop <b>==</b> <span style='color:#b08000;'>1</span>:
                    <b><span style='color:#0000ff;'>print</span></b> <b><span style='color:#bf0303;'>'GGG'</span></b>, nodej.<b><span style='color:#0000ff;'>id</span></b>
                    <span style='color:#006e28;'>self</span>.addNeighbor(nodej)
                <b>if</b> hop <b>==</b> <span style='color:#b08000;'>2</span>:
                    <span style='color:#006e28;'>self</span>.addNotKnown(nodej)
                
                <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>add to the network table..</span></b><b><span style='color:#ff0000;'>'''</span></b>
                <span style='color:#006e28;'>self</span>.addReceived(nodej)

                
    <b>def</b> transmit(<span style='color:#006e28;'>self</span>, pt):
        <span style='color:#006e28;'>self</span>.state <b>=</b> <span style='color:#006e28;'>False</span>
        p <b>=</b> rsObj.uniform(<span style='color:#b08000;'>0</span>,<span style='color:#b08000;'>1</span>)
        <b>if</b> p <b>&lt;</b> pt:
            <span style='color:#006e28;'>self</span>.state <b>=</b> <span style='color:#006e28;'>True</span>  
    
    <b>def</b> setReceiver(<span style='color:#006e28;'>self</span>, channel):
        <span style='color:#006e28;'>self</span>.state <b>=</b> <span style='color:#006e28;'>False</span>
        <span style='color:#006e28;'>self</span>.chId <b>=</b> channel
    
    <b>def</b> receive(<span style='color:#006e28;'>self</span>, pl):
        p <b>=</b> rsObj.uniform(<span style='color:#b08000;'>0</span>,<span style='color:#b08000;'>1</span>) 
        
        <b>if</b> p <b>&gt;</b> pl:

            <b>return</b> <span style='color:#006e28;'>True</span>
        <b>else</b>:
            <b>return</b> <span style='color:#006e28;'>False</span>

<b>def</b> confidence_interval(data, confidence<b>=</b><span style='color:#b08000;'>0.95</span>):
    a <b>=</b> <span style='color:#b08000;'>1.0</span><b>*</b>np.array(data)
    n <b>=</b> <b><span style='color:#0000ff;'>len</span></b>(a)
    m, se <b>=</b> np.mean(a), sp.stats.stderr(a)
    h <b>=</b> se <b>*</b> sp.stats.t._ppf((<span style='color:#b08000;'>1</span><b>+</b>confidence)<b>/</b><span style='color:#b08000;'>2.</span>, n<b>-</b><span style='color:#b08000;'>1</span>)
    <b>return</b> m<b>-</b>h, m, m<b>+</b>h
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------</span></b>
<b>def</b> mean_confidence_interval(data, confidence<b>=</b><span style='color:#b08000;'>0.95</span>):
    a <b>=</b> <span style='color:#b08000;'>1.0</span><b>*</b>np.array(data)
    n <b>=</b> <b><span style='color:#0000ff;'>len</span></b>(a)
    m, se <b>=</b> np.mean(a), sp.stats.sem(a)
    h <b>=</b> se <b>*</b> sp.stats.t._ppf((<span style='color:#b08000;'>1</span><b>+</b>confidence)<b>/</b><span style='color:#b08000;'>2.</span>, n<b>-</b><span style='color:#b08000;'>1</span>)
    <b>return</b> m<b>-</b>h, m, m<b>+</b>h
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------</span></b>
<b>def</b> funcProbOf(C, N):
    a <b>=</b> N
    b <b>=</b> <span style='color:#b08000;'>2</span><b>*</b>C<b>+</b>N<b>-</b><span style='color:#b08000;'>1</span>
    c <b>=</b> C
    f2 <b>=</b> (b <b>-</b> np.sqrt(math.<b><span style='color:#0000ff;'>pow</span></b>(b,<span style='color:#b08000;'>2</span>)<b>-</b><span style='color:#b08000;'>4</span><b>*</b>a<b>*</b>c))<b>/</b>(<span style='color:#b08000;'>1.0</span><b>*</b><span style='color:#b08000;'>2</span><b>*</b>a)
    <b>return</b> f2
<b><span style='color:#ff0000;'>#--------------------------------------------------------------------------</span></b>
<b>def</b> loss_p(p, n):
    a <b>=</b> <span style='color:#b08000;'>1.0</span>
    <b>for</b> i <b>in</b> <b><span style='color:#0000ff;'>range</span></b>(n):
        a <b>=</b> a<b>*</b>(<span style='color:#b08000;'>1</span><b>-</b>p)

    <b>return</b> a
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------</span></b>
<b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>Create all nodes in the Network</span></b><b><span style='color:#ff0000;'>'''</span></b>
<b>def</b> createNodes(n, channelLen, T_period):
    lnodes<b>=</b>{}
    <b>for</b> i <b>in</b> <b><span style='color:#0000ff;'>range</span></b>(<span style='color:#b08000;'>1</span>, n<b>+</b><span style='color:#b08000;'>1</span>):
        node <b>=</b> Node(i,n)
        channel <b>=</b> i<b>%</b>channelLen
        ownSlot <b>=</b> <span style='color:#b08000;'>1</span> <b>+</b> i<b>%</b>(T_period<b>-</b><span style='color:#b08000;'>1</span>)
        node.addOwn(channel, ownSlot)
                
        lnodes[i]<b>=</b> node
    <b>return</b> lnodes
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------</span></b>
<b>def</b> flushIds(Lnodes):
    <b>for</b> i, node <b>in</b> <b><span style='color:#0000ff;'>enumerate</span></b>(Lnodes.values()):
        Lnodes[node.<b><span style='color:#0000ff;'>id</span></b>].flushNeighbors()
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------</span></b>
<b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>returns True if every node have discovered all its neighbors </span></b><b><span style='color:#ff0000;'>'''</span></b>
<b>def</b> all2allComplete(Lnodes):
    <b>for</b> node <b>in</b> Lnodes.values():
        <b>if</b> node.allNetworkDiscovered() <b>==</b> <span style='color:#006e28;'>False</span>:
            <b>return</b> <span style='color:#006e28;'>False</span>
    <b>return</b> <span style='color:#006e28;'>True</span>
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------</span></b>
<b>def</b> addTopology(Xmax, Ymax, Nodes):
    lnodes<b>=</b>{}
    xco <b>=</b> np.arange(<span style='color:#b08000;'>0</span>, Xmax<b>+</b><span style='color:#b08000;'>0.25</span>, <span style='color:#b08000;'>0.25</span>)
    yco <b>=</b> np.arange(<span style='color:#b08000;'>0</span>, Ymax<b>+</b><span style='color:#b08000;'>0.25</span>, <span style='color:#b08000;'>0.25</span>)    
    <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>add coordinates</span></b><b><span style='color:#ff0000;'>'''</span></b>
    <b>for</b> node <b>in</b> Nodes.values():
        x <b>=</b> np.random.choice(xco)
        y <b>=</b> np.random.choice(yco)
        
        node.addCoordinates(x,y)
        
        lnodes[node.<b><span style='color:#0000ff;'>id</span></b>]<b>=</b>node
    <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>add neighbors based on X and Y</span></b><b><span style='color:#ff0000;'>'''</span></b>
    <b>for</b> nodei <b>in</b> lnodes.values():
        <b>for</b> nodej <b>in</b> lnodes.values():
            <b>if</b> nodei.<b><span style='color:#0000ff;'>id</span></b> <b>!=</b> nodej.<b><span style='color:#0000ff;'>id</span></b> <b>and</b> nodei.isNeighbor(nodej):
                nodei.neighbors.append(nodej.<b><span style='color:#0000ff;'>id</span></b>)
    <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>Print Coordinates</span></b><b><span style='color:#ff0000;'>'''</span></b>           
    <b>for</b> node <b>in</b> lnodes.values():
        <b><span style='color:#0000ff;'>print</span></b> [node.<b><span style='color:#0000ff;'>id</span></b>, node.xc0, node.yc0],<b><span style='color:#bf0303;'>'-&gt;'</span></b>,node.neighbors
        
        
    <b>for</b> node <b>in</b> lnodes.values():
        plt.plot(node.xc0, node.yc0, <b><span style='color:#bf0303;'>'ro'</span></b>, lw<b>=</b><span style='color:#b08000;'>3</span>)
    
    plt.grid(<span style='color:#006e28;'>True</span>)
    plt.show()
    
    saveTopology(<b><span style='color:#bf0303;'>'./NodePositions2.dat'</span></b>, lnodes)
            
    <b>return</b> lnodes
    
<b>def</b> plot_cdf(a):
    a.sort()
    yvals<b>=</b>np.arange(<b><span style='color:#0000ff;'>len</span></b>(a))<b>/</b><b><span style='color:#0000ff;'>float</span></b>(<b><span style='color:#0000ff;'>len</span></b>(a))
    plt.plot(a, yvals )  
    plt.show()
    <b><span style='color:#ff0000;'>#plt.close()</span></b>
    <b><span style='color:#0000ff;'>print</span></b> <b><span style='color:#bf0303;'>'gonga....'</span></b>
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------</span></b>
<b>def</b> write_file(fname, a):
    <b>with</b> <b><span style='color:#0000ff;'>open</span></b>(fname,<b><span style='color:#bf0303;'>'w'</span></b>) <span style='color:#924c9d;'>as</span> fw:
        <b>for</b> i, val <b>in</b> <b><span style='color:#0000ff;'>enumerate</span></b>(a):
            <b>if</b> i<b>+</b><span style='color:#b08000;'>1</span> <b>&lt;</b> <b><span style='color:#0000ff;'>len</span></b>(a):
                fw.write(<b><span style='color:#0000ff;'>str</span></b>(val)<b>+</b><b><span style='color:#bf0303;'>','</span></b>)
            <b>else</b>:
                fw.write(<b><span style='color:#0000ff;'>str</span></b>(val))
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------</span></b>
<b>def</b> read_file(fname):
    <b>with</b> <b><span style='color:#0000ff;'>open</span></b>(fname,<b><span style='color:#bf0303;'>'r'</span></b>) <span style='color:#924c9d;'>as</span> fr:    
        dt <b>=</b> fr.read().split(<b><span style='color:#bf0303;'>','</span></b>)
        xx <b>=</b>[<b><span style='color:#0000ff;'>int</span></b>(x) <b>for</b> x <b>in</b> dt]
        <b>return</b> xx    
<b><span style='color:#ff0000;'>#--------------------------------------------------------------------------- </span></b>
<b>def</b> saveTopology(fname, listNodes):
    <b>with</b> <b><span style='color:#0000ff;'>open</span></b>(fname, <b><span style='color:#bf0303;'>'w'</span></b>) <span style='color:#924c9d;'>as</span> fw:
        <b>for</b> ii, node <b>in</b> <b><span style='color:#0000ff;'>enumerate</span></b>(listNodes.values()):
            <b>if</b> ii<b>+</b><span style='color:#b08000;'>1</span> <b>&lt;</b> <b><span style='color:#0000ff;'>len</span></b>(listNodes):
                fw.write(<b><span style='color:#0000ff;'>str</span></b>(node.xc0)<b>+</b><b><span style='color:#bf0303;'>','</span></b>)
                fw.write(<b><span style='color:#0000ff;'>str</span></b>(node.yc0)<b>+</b><b><span style='color:#bf0303;'>':'</span></b>)
            <b>else</b>:
                fw.write(<b><span style='color:#0000ff;'>str</span></b>(node.xc0)<b>+</b><b><span style='color:#bf0303;'>','</span></b>)
                fw.write(<b><span style='color:#0000ff;'>str</span></b>(node.yc0))                                          
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------         </span></b>
<b>def</b> readTopology(fname):
    <b>with</b> <b><span style='color:#0000ff;'>open</span></b>(fname,<b><span style='color:#bf0303;'>'r'</span></b>) <span style='color:#924c9d;'>as</span> fr:
        dt <b>=</b> fr.read().split(<b><span style='color:#bf0303;'>':'</span></b>)
        <b><span style='color:#ff0000;'>#print dt</span></b>
        xx <b>=</b> [(<b><span style='color:#0000ff;'>float</span></b>(x.split(<b><span style='color:#bf0303;'>','</span></b>)[<span style='color:#b08000;'>0</span>]),<b><span style='color:#0000ff;'>float</span></b>(x.split(<b><span style='color:#bf0303;'>','</span></b>)[<span style='color:#b08000;'>1</span>])) <b>for</b> x <b>in</b> dt]
        <b><span style='color:#ff0000;'>#for x, y in xx:            </span></b>
            <b><span style='color:#ff0000;'>#plt.plot(x, y, 'ro', lw=8)</span></b>
    
        <b><span style='color:#ff0000;'>#plt.grid(True)</span></b>
        <b><span style='color:#ff0000;'>#title('[100m x 100m]:::::::NETWORK TOPOLOGY::::::')</span></b>
        <b><span style='color:#ff0000;'>#xlabel('X-$axis$')</span></b>
        <b><span style='color:#ff0000;'>#ylabel('Y-$axis$')</span></b>
        <b><span style='color:#ff0000;'>#plt.show()</span></b>
        <b>return</b> xx
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------                  </span></b>
<b>def</b> nodesAddCoordinates(network, lnodes):
    <b>if</b> <b><span style='color:#0000ff;'>len</span></b>(network) <b>&lt;</b> <b><span style='color:#0000ff;'>len</span></b>(lnodes):
        <b><span style='color:#0000ff;'>print</span></b> <b><span style='color:#bf0303;'>'WARNING:::: COORDINATES VECTOR SMALLER THAN SIZE OF THE NETWORK'</span></b>
        exit(<span style='color:#b08000;'>0</span>)
    <b><span style='color:#0000ff;'>print</span></b> <b><span style='color:#bf0303;'>'''</span></b><b><span style='color:#bf0303;'>==&gt;downloading network topology.....</span></b><b><span style='color:#bf0303;'>'''</span></b>
    
    <b><span style='color:#ff0000;'>#fig  = plt.figure()</span></b>
    <b><span style='color:#ff0000;'>#axes = fig.add_subplot(1,1,1) </span></b>
    
    plt.axes()
    
    <b>for</b> node, coord <b>in</b> <b><span style='color:#0000ff;'>zip</span></b>(lnodes.values(), network):
            x, y <b>=</b> coord
            lnodes[node.<b><span style='color:#0000ff;'>id</span></b>].addCoordinates(x,y) 
    <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>add neighbors based on X and Y</span></b><b><span style='color:#ff0000;'>'''</span></b>
    <b><span style='color:#0000ff;'>print</span></b> <b><span style='color:#bf0303;'>'==&gt;computing neighborhood...'</span></b>
    <b>for</b> nodei <b>in</b> lnodes.values():
        
        <b>for</b> nodej <b>in</b> lnodes.values():
            <b>if</b> nodei.<b><span style='color:#0000ff;'>id</span></b> <b>!=</b> nodej.<b><span style='color:#0000ff;'>id</span></b> <b>and</b> nodei.isNeighbor(nodej):
                nodei.neighbors.append(nodej)
        
        <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>PLOT NODE LOCATION</span></b><b><span style='color:#ff0000;'>'''</span></b>
        x, y <b>=</b> nodei.xc0, nodei.yc0
        <b><span style='color:#ff0000;'>#plt.plot(x, y, 'ro', lw=8)</span></b>
        circxy <b>=</b> plt.Circle((x, y), radius <b>=</b> <span style='color:#b08000;'>2</span>, fc<b>=</b><b><span style='color:#bf0303;'>'k'</span></b>)<b><span style='color:#ff0000;'>#,</span></b>
                 <b><span style='color:#ff0000;'>#fill = False,</span></b>
                 <b><span style='color:#ff0000;'>#edgecolor='black', linewidth=1, ls='solid',</span></b>
                 <b><span style='color:#ff0000;'>#alpha=1.0, label=&quot;%s&quot;%str(nodei.id))</span></b>
        plt.gca().add_patch(circxy)
        
        plt.text(x<b>-</b><span style='color:#b08000;'>0.5</span><b>*</b><span style='color:#b08000;'>2</span>, y<b>-</b><span style='color:#b08000;'>0.5</span><b>*</b><span style='color:#b08000;'>2</span>, <b><span style='color:#0000ff;'>str</span></b>(nodei.<b><span style='color:#0000ff;'>id</span></b>), fontsize<b>=</b><span style='color:#b08000;'>10</span>, color<b>=</b><b><span style='color:#bf0303;'>'white'</span></b>)
        
        <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>PLOT LINKS</span></b><b><span style='color:#ff0000;'>'''</span></b>
        <b>for</b> neighNode <b>in</b> nodei.neighbors:
            x <b>=</b> (nodei.xc0, neighNode.xc0)
            y <b>=</b> (nodei.yc0, neighNode.yc0)
            plot(x,y, color<b>=</b><b><span style='color:#bf0303;'>'b'</span></b>, linestyle<b>=</b><b><span style='color:#bf0303;'>'-'</span></b>, linewidth<b>=</b><span style='color:#b08000;'>0.2</span>)
    
    <b><span style='color:#ff0000;'>#plt.axis('scaled')</span></b>
    
    xlim([<span style='color:#b08000;'>0</span>,<span style='color:#b08000;'>100</span>])
    ylim([<span style='color:#b08000;'>0</span>,<span style='color:#b08000;'>100</span>])
    
    <b><span style='color:#ff0000;'>#plt.axis('scaled')</span></b>
    
    plt.grid(<span style='color:#006e28;'>True</span>)
    title(<b><span style='color:#bf0303;'>'[100m x 100m]::::::RANDOM NETWORK TOPOLOGY::::::'</span></b>)
    xlabel(<b><span style='color:#bf0303;'>'X-$axis$ (m)'</span></b>)
    ylabel(<b><span style='color:#bf0303;'>'Y-$axis$ (m)'</span></b>)            
    plt.show()
        <b><span style='color:#ff0000;'>#print [nodei.id, nodei.xc0, nodei.yc0],'-&gt;',nodei.neighbors</span></b>

<b><span style='color:#ff0000;'>#--------------------------------------------------------------------------- </span></b>
<b>def</b> networkUpdate(lnodes):
    plt.clf()
    
    plt.axes()
    
    <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>PLOT NODE LOCATION</span></b><b><span style='color:#ff0000;'>'''</span></b>
    <b>for</b> nodei <b>in</b> lnodes.values():
        x, y <b>=</b> nodei.xc0, nodei.yc0
        <b><span style='color:#ff0000;'>#mpl.patches.Circle(x,y, radius=3, color='red')</span></b>
        circxy <b>=</b> plt.Circle((x, y), radius <b>=</b> <span style='color:#b08000;'>2</span>, fc<b>=</b><b><span style='color:#bf0303;'>'k'</span></b>)<b><span style='color:#ff0000;'>#,</span></b>
        plt.gca().add_patch(circxy)
        plt.text(x<b>-</b><span style='color:#b08000;'>0.5</span><b>*</b><span style='color:#b08000;'>2</span>, y<b>-</b><span style='color:#b08000;'>0.5</span><b>*</b><span style='color:#b08000;'>2</span>, <b><span style='color:#0000ff;'>str</span></b>(nodei.<b><span style='color:#0000ff;'>id</span></b>), fontsize<b>=</b><span style='color:#b08000;'>10</span>, color<b>=</b><b><span style='color:#bf0303;'>'white'</span></b>)
        
        <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>PLOT LINKS</span></b><b><span style='color:#ff0000;'>'''</span></b>
        <b>for</b> neighNode <b>in</b> nodei.neighbors1Hop:
            <b><span style='color:#0000ff;'>print</span></b> <b><span style='color:#0000ff;'>len</span></b>(nodei.neighbors1Hop), nodei.<b><span style='color:#0000ff;'>id</span></b>, nodei.neighbors1Hop
            x <b>=</b> (nodei.xc0, neighNode.xc0)
            y <b>=</b> (nodei.yc0, neighNode.yc0)
            plot(x,y, color<b>=</b><b><span style='color:#bf0303;'>'b'</span></b>, linestyle<b>=</b><b><span style='color:#bf0303;'>'-'</span></b>, linewidth<b>=</b><span style='color:#b08000;'>0.2</span>)
    
    <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>RESTORE GRID AND AXIS NAMES</span></b><b><span style='color:#ff0000;'>'''</span></b>
    xlim([<span style='color:#b08000;'>0</span>,<span style='color:#b08000;'>100</span>])
    ylim([<span style='color:#b08000;'>0</span>,<span style='color:#b08000;'>100</span>])
    
    plt.grid(<span style='color:#006e28;'>True</span>)
    title(<b><span style='color:#bf0303;'>'[100m x 100m]:::::::RANDOM NETWORK TOPOLOGY::::::'</span></b>)
    xlabel(<b><span style='color:#bf0303;'>'X-$axis$ (m)'</span></b>)
    ylabel(<b><span style='color:#bf0303;'>'Y-$axis$ (m)'</span></b>)            
    plt.show()            
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------            </span></b>
<b>def</b> runSim():
  
  
      
  <b>global</b> csvFd, CSize, KSize  
  
  <b>global</b> maxHopCount, T_period
  
  T_period <b>=</b> <span style='color:#b08000;'>3</span>
  
  superFrames<b>=</b>[<span style='color:#b08000;'>2</span>,<span style='color:#b08000;'>3</span>,<span style='color:#b08000;'>4</span>,<span style='color:#b08000;'>5</span>,<span style='color:#b08000;'>6</span>,<span style='color:#b08000;'>10</span>]
  ptOwn    <b>=</b> <span style='color:#b08000;'>0.1</span>
  
  numRepeat   <b>=</b> <span style='color:#b08000;'>100</span>
    
  <b><span style='color:#ff0000;'>#nodes = [2, 4]+range(5, 51,5)</span></b>
  channels<b>=</b>[<span style='color:#b08000;'>2</span>,<span style='color:#b08000;'>4</span>,<span style='color:#b08000;'>8</span>,<span style='color:#b08000;'>10</span>,<span style='color:#b08000;'>12</span>,<span style='color:#b08000;'>14</span>,<span style='color:#b08000;'>16</span>]  
  
  nodes <b>=</b> [<span style='color:#b08000;'>100</span>]<b><span style='color:#ff0000;'>#range(60, 101,10)</span></b>
  channels<b>=</b>[<span style='color:#b08000;'>6</span>]<b><span style='color:#ff0000;'>#[4,8]</span></b>
  
  
  networkCoord<b>=</b>readTopology(<b><span style='color:#bf0303;'>'./NodePositions.dat'</span></b>)
  
  <b><span style='color:#ff0000;'>#print networkCoord</span></b>
  
  <b><span style='color:#ff0000;'>#exit()</span></b>
  
  <b>for</b> frameLen <b>in</b> [<span style='color:#b08000;'>3</span>]: <b><span style='color:#ff0000;'>#superFrames:</span></b>
      T_period <b>=</b> frameLen
      
      <b><span style='color:#0000ff;'>print</span></b> <b><span style='color:#bf0303;'>'----------------------------------------------'</span></b>
      
      <b>for</b> num_nodes <b>in</b> nodes: 
          <b>for</b> channel <b>in</b> channels:
              pt <b>=</b> funcProbOf(channel, num_nodes)
    
              vec_times <b>=</b> []
              <b><span style='color:#ff0000;'>##t_slot = 1</span></b>
              <b><span style='color:#0000ff;'>print</span></b> <b><span style='color:#bf0303;'>'==&gt; [T='</span></b>,frameLen,<b><span style='color:#bf0303;'>' N='</span></b>,num_nodes,<b><span style='color:#bf0303;'>' K='</span></b>,channel,<b><span style='color:#bf0303;'>']'</span></b>
              
              Lnodes <b>=</b> createNodes(num_nodes, channel, T_period)
              
              <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>Add topology</span></b><b><span style='color:#ff0000;'>'''</span></b>
              <b><span style='color:#ff0000;'>#addTopology(100, 100, Lnodes)</span></b>
              <b><span style='color:#ff0000;'>#return</span></b>
              
              <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>Add Coordinates to nodes..</span></b><b><span style='color:#ff0000;'>'''</span></b>
              nodesAddCoordinates(networkCoord, Lnodes)
              
              <b><span style='color:#ff0000;'>#plot_cdf(np.random.uniform(0, 1, 100))</span></b>
              
              <b><span style='color:#ff0000;'>#return</span></b>
              
              <b>for</b> t  <b>in</b> <b><span style='color:#0000ff;'>range</span></b>(numRepeat):
                  <b><span style='color:#ff0000;'>#A=np.eye(n)</span></b>
                  t_slot <b>=</b> <span style='color:#b08000;'>0</span>
                  <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>clear neighbors list</span></b><b><span style='color:#ff0000;'>'''</span></b>
                  flushIds(Lnodes)
                  
                  <b>while</b> all2allComplete(Lnodes) <b>==</b> <span style='color:#006e28;'>False</span>:
                      t_slot <b>=</b> t_slot <b>+</b> <span style='color:#b08000;'>1</span> 
                      
                      <b><span style='color:#0000ff;'>print</span></b> <b><span style='color:#bf0303;'>'['</span></b>, t , t_slot,<b><span style='color:#bf0303;'>']'</span></b>
                      
                                        
                      <b>if</b> t_slot<b>%</b><span style='color:#b08000;'>10</span> <b>==</b> <span style='color:#b08000;'>0</span>:
                          networkUpdate(Lnodes)
                      
                      <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>THIS IS BEACONING SLOT</span></b><b><span style='color:#ff0000;'>'''</span></b>
                      <b>if</b> t_slot<b>%</b>T_period <b>==</b> <span style='color:#b08000;'>0</span>:
                      
                          <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>each node uniformly at random selected a channel</span></b><b><span style='color:#ff0000;'>'''</span></b>
                          rand_ch <b>=</b> rsObj.randint(<span style='color:#b08000;'>0</span>, channel, num_nodes).tolist()
                          
                          <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>Transmission vector</span></b><b><span style='color:#ff0000;'>'''</span></b>
                          tx_vec <b>=</b> rsObj.uniform(<span style='color:#b08000;'>0</span>,<span style='color:#b08000;'>1</span>, num_nodes).tolist()
                          
                          <b>for</b> ii, node <b>in</b> <b><span style='color:#0000ff;'>enumerate</span></b>(Lnodes.values()):
                              <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>Check if node is receiver</span></b><b><span style='color:#ff0000;'>'''</span></b>
                              <b>if</b> tx_vec[ii] <b>&gt;</b> pt:
                                  txList <b>=</b> []
                                  <b>for</b> jj, nodeX <b>in</b> <b><span style='color:#0000ff;'>enumerate</span></b>(Lnodes.values()):
                                      <b>if</b> node.<b><span style='color:#0000ff;'>id</span></b> <b>!=</b> nodeX.<b><span style='color:#0000ff;'>id</span></b> <b>and</b> rand_ch[ii] <b>==</b> rand_ch[jj] <b>and</b> node.isNeighbor(nodeX):
                                          <b>if</b> tx_vec[jj] <b>&lt;</b> pt:
                                              txList.append(nodeX)
                                  <b>if</b> <b><span style='color:#0000ff;'>len</span></b>(txList) <b>==</b> <span style='color:#b08000;'>1</span>:
                                      Lnodes[node.<b><span style='color:#0000ff;'>id</span></b>].disseminate(txList[<span style='color:#b08000;'>0</span>])
                          <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>END of TX</span></b><b><span style='color:#ff0000;'>'''</span></b>   
                      <b>else</b>:
                            <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>THIS IS A DIFFERENT SLOT-NON BEACON</span></b><b><span style='color:#ff0000;'>'''</span></b>
                            <b>for</b> jj, node <b>in</b> <b><span style='color:#0000ff;'>enumerate</span></b>(Lnodes.values()):
                                <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>determine which slot we are</span></b><b><span style='color:#ff0000;'>'''</span></b>
                                slotOffset<b>=</b> <span style='color:#b08000;'>1</span> <b>+</b> t_slot<b>%</b>(T_period<b>-</b><span style='color:#b08000;'>1</span>)
                                
                                <b>if</b> node.isOwnSlot(slotOffset):
                                    <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>it is my slot.. transmit with probability: pOwn</span></b><b><span style='color:#ff0000;'>'''</span></b>
                                    Lnodes[node.<b><span style='color:#0000ff;'>id</span></b>].transmitOwn(ptOwn)
                                    <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>@note HERE MAYBE try to CHECK status here to determine if we...</span></b><b><span style='color:#ff0000;'>'''</span></b>
                                <b>else</b>:
                                    <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>first I select one channel of not heard nodes yet</span></b><b><span style='color:#ff0000;'>'''</span></b>
                                    vCh<b>=</b>[nodeC.chId <b>for</b> nodeC <b>in</b> Lnodes.values() <b>if</b> nodeC.<b><span style='color:#0000ff;'>id</span></b> <b>!=</b> node.<b><span style='color:#0000ff;'>id</span></b> <b>and</b> nodeC.isOwnSlot(slotOffset) <b>and</b> nodeC <b>in</b> node.notKnownNeigh]
                                    
                                    <b>if</b> <b><span style='color:#0000ff;'>len</span></b>(vCh):
                                        <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>choose channel UNIFORMLY based on the not YET heard nodes</span></b><b><span style='color:#ff0000;'>'''</span></b>
                                        randChannel<b>=</b>rsObj.choice(vCh)
                                        Lnodes[node.<b><span style='color:#0000ff;'>id</span></b>].setReceiver(randChannel)
                                    <b>else</b>:
                                        <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>OTHERWISE choose any random channel COLUMN</span></b><b><span style='color:#ff0000;'>'''</span></b>
                                        randChannel <b>=</b> rsObj.choice(<b><span style='color:#0000ff;'>range</span></b>(channel))
                                        Lnodes[node.<b><span style='color:#0000ff;'>id</span></b>].setReceiver(randChannel)
                            <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>Now select who succeeded</span></b><b><span style='color:#ff0000;'>'''</span></b>
                            <b>for</b> node <b>in</b> Lnodes.values():
                                <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>I am a receiver</span></b><b><span style='color:#ff0000;'>'''</span></b>
                                <b>if</b> node.state <b>==</b> <span style='color:#006e28;'>False</span>:
                                    txList<b>=</b>[]
                                    <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>check for transmitters</span></b><b><span style='color:#ff0000;'>'''</span></b>
                                    <b>for</b> nodeTx <b>in</b> Lnodes.values():
                                        <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>Not Myself, and Transmitter is on the same channel I am..</span></b><b><span style='color:#ff0000;'>'''</span></b>
                                        <b>if</b> nodeTx.state <b>==</b> <span style='color:#006e28;'>True</span> <b>and</b> node.chId <b>==</b> nodeTx.chId <b>and</b> node.isNeighbor(nodeTx):
                                            <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>This is a transmitter</span></b><b><span style='color:#ff0000;'>'''</span></b>
                                            txList.append(nodeTx)
                                    <b>if</b> <b><span style='color:#0000ff;'>len</span></b>(txList) <b>==</b> <span style='color:#b08000;'>1</span>:
                                        <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>ONE NODE TRANSMITTED..SUCCESS</span></b><b><span style='color:#ff0000;'>'''</span></b>                                        
                                        Lnodes[node.<b><span style='color:#0000ff;'>id</span></b>].disseminate(txList[<span style='color:#b08000;'>0</span>])
                  <b><span style='color:#ff0000;'>#end While</span></b>
                  vec_times.append(t_slot)
              <b><span style='color:#ff0000;'>#end for</span></b>
              <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>PLOT CDF...</span></b><b><span style='color:#ff0000;'>'''</span></b>
              plot_cdf(vec_times)     
              vec_times.sort()
              <b><span style='color:#0000ff;'>print</span></b> vec_times
            
              discTime <b>=</b> mean(vec_times)<b><span style='color:#ff0000;'>#/(1-0.2)</span></b>
              
              <b><span style='color:#0000ff;'>print</span></b> <b><span style='color:#bf0303;'>'Mean for'</span></b>,<b><span style='color:#bf0303;'>' [T='</span></b>, T_period,<b><span style='color:#bf0303;'>'N ='</span></b>, num_nodes, <b><span style='color:#bf0303;'>'K='</span></b>,channel, <b><span style='color:#0000ff;'>round</span></b>(pt, <span style='color:#b08000;'>3</span>), <b><span style='color:#bf0303;'>'-&gt;'</span></b>, <b><span style='color:#0000ff;'>round</span></b>(discTime, <span style='color:#b08000;'>2</span>),<b><span style='color:#bf0303;'>']'</span></b>                                    
      <b><span style='color:#ff0000;'>#end for</span></b>
  <b><span style='color:#ff0000;'>###</span></b>
  <b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>comment</span></b><b><span style='color:#ff0000;'>'''</span></b>
  <b><span style='color:#ff0000;'>## </span></b>
<b><span style='color:#ff0000;'>#---------------------------------------------------------------------------</span></b>
<b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>======================================================================</span></b><b><span style='color:#ff0000;'>'''</span></b>
<b>if</b> <span style='color:#006e28;'>__name__</span> <b>==</b> <b><span style='color:#bf0303;'>'__main__'</span></b>:
    
    runSim()      
    
 
<b><span style='color:#ff0000;'>'''</span></b><b><span style='color:#ff0000;'>======================================================================</span></b><b><span style='color:#ff0000;'>'''</span></b>
</pre>
</body>
</html>
